<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Full-Screen Dragon Snake</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    html, body {
      margin: 0; 
      padding: 0; 
      overflow: hidden; /* prevent scrolling */
      background: #000;
      font-family: Arial, sans-serif;
      color: #fff;
    }
    #game-canvas {
      position: fixed;
      top: 0; left: 0; 
      width: 100vw; 
      height: 100vh; 
      display: block;
      background: #111;
    }
    /* Overlays */
    .overlay {
      position: fixed;
      top: 0; left: 0; 
      width: 100vw; 
      height: 100vh;
      background: rgba(0,0,0,0.75);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999; 
    }
    .hidden { display: none; }

    /* Common styling for overlays */
    .overlay-content {
      text-align: center;
      max-width: 90vw;
      background: #222;
      padding: 20px;
      border-radius: 10px;
    }
    h1,h2,h3,p { margin: 10px 0; }
    button {
      background: #4CAF50;
      border: none;
      padding: 10px 20px;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      margin: 6px;
      font-size: 16px;
    }
    button:hover {
      background: #45a049;
    }
    #leaderboard-container {
      margin-top: 10px;
      text-align: left;
    }
    #leaderboard-container h3 {
      margin-bottom: 6px;
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <!-- Main Menu Overlay -->
  <div id="menu-overlay" class="overlay">
    <div class="overlay-content">
      <h2>Dragon Snake</h2>
      <p id="credits-info">Stars: …</p>
      <button id="pay-btn" onclick="payAndStart()">Pay 1 Star to Play</button>
      <button onclick="viewLeaderboard()">View Leaderboard</button>
      <button onclick="topUpInfo()">Top Up Stars</button>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameover-overlay" class="overlay hidden">
    <div class="overlay-content">
      <h2>Game Over!</h2>
      <p id="gameover-reason"></p>
      <p>Score: <span id="final-score">0</span></p>
      <div id="leaderboard-container"></div>
      <button onclick="viewLeaderboard()">View Leaderboard</button>
      <button onclick="payAndStart()">Play Again (Pay 1 Star)</button>
      <button onclick="closeOverlays()">Close</button>
    </div>
  </div>

<script>
/* =========================
   Global Config
========================= */
const backendUrl = "https://hoursnake.onrender.com"; // your server
let telegramUserId = null;
let game = null; // to store the game instance

/* =========================
   Telegram WebApp Setup
========================= */
window.onload = function() {
  try {
    const tg = Telegram.WebApp;
    tg.expand(); // Attempt to make the in-app browser as tall as possible
    telegramUserId = tg.initDataUnsafe?.user?.id;
    if (!telegramUserId) {
      alert("No Telegram user ID found. Are you in Telegram?");
    }
  } catch (err) {
    console.log("Telegram init error:", err);
  }
  // fetch initial star count
  fetchCredits();
};

/* =========================
   Show/Hide Overlays
========================= */
function showMenuOverlay() {
  document.getElementById("menu-overlay").classList.remove("hidden");
}
function hideMenuOverlay() {
  document.getElementById("menu-overlay").classList.add("hidden");
}
function showGameOverOverlay(reason, score) {
  document.getElementById("gameover-reason").textContent = reason;
  document.getElementById("final-score").textContent = score;
  document.getElementById("gameover-overlay").classList.remove("hidden");
}
function hideGameOverOverlay() {
  document.getElementById("gameover-overlay").classList.add("hidden");
}
function closeOverlays() {
  // close all overlays -> show main menu again
  hideGameOverOverlay();
  showMenuOverlay();
  fetchCredits();
}

/* =========================
   Top Up Info
========================= */
function topUpInfo() {
  alert("Ask the admin or pay externally. Then admin calls /admin/manual-topup with your telegram_id.\nCheck your new stars here!");
}

/* =========================
   1) Fetch & Display Credits
========================= */
async function fetchCredits() {
  if (!telegramUserId) return;
  try {
    const resp = await fetch(`${backendUrl}/game/get-credits`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ telegram_id: telegramUserId })
    });
    const data = await resp.json();
    const cInfo = document.getElementById("credits-info");
    if (data.success) {
      cInfo.textContent = `Stars: ${data.stars}`;
    } else {
      cInfo.textContent = "Stars: Error";
    }
  } catch (err) {
    console.error("Error fetching credits:", err);
    document.getElementById("credits-info").textContent = "Stars: Error";
  }
}

/* =========================
   2) Pay 1 Star & Start Game
========================= */
async function payAndStart() {
  if (!telegramUserId) {
    alert("No Telegram user ID. Are you inside Telegram?");
    return;
  }
  try {
    // Attempt to deduct 1 star
    const resp = await fetch(`${backendUrl}/game/deduct-credit`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ telegram_id: telegramUserId })
    });
    const data = await resp.json();
    if (!data.success) {
      alert(data.message || "Not enough stars. Top up first!");
      return;
    }
    // start game
    hideMenuOverlay();
    hideGameOverOverlay();
    startGame();
  } catch (err) {
    console.error("Error paying star:", err);
    alert("Payment error. See console.");
  }
}

/* =========================
   3) View Leaderboard
========================= */
async function viewLeaderboard() {
  try {
    const resp = await fetch(`${backendUrl}/current-leaderboard`);
    const data = await resp.json();
    if (!data.success) {
      alert("Error fetching leaderboard.");
      return;
    }
    // If we are in the gameover overlay, show it there;
    // else maybe show an alert or something
    const container = document.getElementById("leaderboard-container");
    if (!container) {
      alert("No leaderboard container found!");
      return;
    }
    let html = "<h3>Top 10 Leaderboard</h3>";
    if (!data.leaderboard || data.leaderboard.length === 0) {
      html += "<p>No scores recorded yet.</p>";
    } else {
      data.leaderboard.forEach((item, i) => {
        const uname = item.username || "Anon";
        html += `<p>${i+1}. ${uname} — ${item.score}</p>`;
      });
    }
    container.innerHTML = html;
    // Switch to gameover overlay if you want, or remain in the menu overlay if that’s visible
    if (!document.getElementById("gameover-overlay").classList.contains("hidden")) {
      // Already in gameover overlay, so just show data there
    } else if (!document.getElementById("menu-overlay").classList.contains("hidden")) {
      // If needed, we could show a separate overlay for LB,
      // but for simplicity, let's just do alert:
      alert(html.replace(/<[^>]+>/g, '')); // strip HTML in a quick hack
    }
  } catch (err) {
    console.error("Leaderboard fetch error:", err);
    alert("Leaderboard error. See console.");
  }
}

/* =========================
   4) The Snake Game
   (60s time limit, scoreboard, etc.)
========================= */
function startGame() {
  game = new DragonGame("game-canvas");
  game.init((reason, finalScore) => {
    // onGameOver callback
    showGameOverOverlay(reason, finalScore);
    // Also submit score to the server
    if (telegramUserId) {
      fetch(`${backendUrl}/game/submit-score`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ telegram_id: telegramUserId, score: finalScore })
      }).then(r=>r.json())
        .then(d=>console.log("Score submit resp:", d))
        .catch(err => console.error("Score submit err:", err));
    }
  });
}

// Minimal DragonGame example
class DragonGame {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext("2d");
    // full screen dims
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    window.addEventListener("resize", () => {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    });

    this.gridSize = 20;
    this.snake = null;
    this.food = null;
    this.score = 0;
    this.gameOver = false;

    this.gameTime = 60000;
    this.startTime = null;
    this.timeLeft = this.gameTime;

    this.speed = 8; // moves/sec
    this.lastRenderTime = 0;

    this.onGameOver = null; // callback
    this.handleKey = this.handleKey.bind(this);
    this.handleTouchStart = this.handleTouchStart.bind(this);
    this.handleTouchEnd   = this.handleTouchEnd.bind(this);

    this.touchStartX = 0;
    this.touchStartY = 0;
  }

  init(onGameOverCallback) {
    this.onGameOver = onGameOverCallback;
    this.snake = new Snake(this.gridSize);
    this.snake.reset();
    this.food = this.createFood();
    this.score = 0;
    this.gameOver = false;
    this.startTime = null;
    this.lastRenderTime = 0;

    document.addEventListener("keydown", this.handleKey);
    this.canvas.addEventListener("touchstart", this.handleTouchStart, { passive:false });
    this.canvas.addEventListener("touchend", this.handleTouchEnd, { passive:false });

    requestAnimationFrame(this.gameLoop.bind(this));
  }

  gameLoop(t) {
    if (this.gameOver) return;
    if (!this.startTime) this.startTime = performance.now();

    let elapsed = t - this.lastRenderTime;
    if (elapsed < 1000/this.speed) {
      requestAnimationFrame(this.gameLoop.bind(this));
      return;
    }
    this.lastRenderTime = t;

    // check time
    const now = performance.now();
    const timeSpent = now - this.startTime;
    this.timeLeft = Math.max(0, this.gameTime - timeSpent);
    if (this.timeLeft <= 0) {
      this.endGame("Time's up!");
      return;
    }

    // move snake
    const ate = this.snake.move(this.food);
    if (ate) {
      this.score++;
      this.food = this.createFood();
      // optional floating text or effect
    }
    if (this.snake.checkCollision()) {
      this.endGame("You collided with yourself!");
      return;
    }

    // draw
    this.draw();
    requestAnimationFrame(this.gameLoop.bind(this));
  }

  createFood() {
    let tries = 0;
    let pos = null;
    while(tries<100) {
      pos = { 
        x: Math.floor(Math.random()*this.gridSize),
        y: Math.floor(Math.random()*this.gridSize)
      };
      if (!this.snake.body.some(s => s.x===pos.x && s.y===pos.y)) break;
      tries++;
    }
    return pos||{x:0,y:0};
  }

  draw() {
    const w = this.canvas.width;
    const h = this.canvas.height;
    this.ctx.fillStyle = "#222";
    this.ctx.fillRect(0,0,w,h);

    // cell size
    const cellW = w/this.gridSize;
    const cellH = h/this.gridSize;

    // snake
    this.snake.body.forEach((seg, i) => {
      this.ctx.fillStyle = (i===0) ? "#ff0000" : "#00ff00"; // head red, body green
      const x = seg.x*cellW, y = seg.y*cellH;
      this.ctx.fillRect(x, y, cellW, cellH);
    });

    // food
    this.ctx.fillStyle = "#ffff00";
    const fx = this.food.x*cellW, fy = this.food.y*cellH;
    this.ctx.fillRect(fx, fy, cellW, cellH);
  }

  endGame(reason) {
    this.gameOver = true;
    document.removeEventListener("keydown", this.handleKey);
    this.canvas.removeEventListener("touchstart", this.handleTouchStart);
    this.canvas.removeEventListener("touchend", this.handleTouchEnd);
    if (this.onGameOver) this.onGameOver(reason, this.score);
  }

  handleKey(e) {
    e.preventDefault();
    switch(e.key) {
      case "ArrowUp":    this.snake.changeDirection("up"); break;
      case "ArrowDown":  this.snake.changeDirection("down"); break;
      case "ArrowLeft":  this.snake.changeDirection("left"); break;
      case "ArrowRight": this.snake.changeDirection("right"); break;
    }
  }

  handleTouchStart(e) {
    e.preventDefault();
    if (e.touches.length>0) {
      this.touchStartX = e.touches[0].clientX;
      this.touchStartY = e.touches[0].clientY;
    }
  }
  handleTouchEnd(e) {
    e.preventDefault();
    const dx = e.changedTouches[0].clientX - this.touchStartX;
    const dy = e.changedTouches[0].clientY - this.touchStartY;
    const threshold=30;
    if (Math.abs(dx)<threshold && Math.abs(dy)<threshold) return;
    if (Math.abs(dx)>Math.abs(dy)) {
      if (dx>0) this.snake.changeDirection("right");
      else      this.snake.changeDirection("left");
    } else {
      if (dy>0) this.snake.changeDirection("down");
      else      this.snake.changeDirection("up");
    }
  }
}

// minimal Snake class
class Snake {
  constructor(gridSize){
    this.gridSize = gridSize;
  }
  reset() {
    this.direction = "right";
    this.nextDir = "right";
    const mid = Math.floor(this.gridSize/2);
    this.body = [
      {x: mid-1, y: mid},
      {x: mid-2, y: mid},
    ];
  }
  changeDirection(newD) {
    const opp = { up:"down", down:"up", left:"right", right:"left" };
    if (opp[newD]!==this.direction) this.nextDir=newD;
  }
  move(food) {
    this.direction=this.nextDir;
    const head={...this.body[0]};
    if(this.direction==="up") head.y--;
    if(this.direction==="down") head.y++;
    if(this.direction==="left") head.x--;
    if(this.direction==="right") head.x++;
    // wrap
    if(head.x<0) head.x=this.gridSize-1;
    if(head.x>=this.gridSize) head.x=0;
    if(head.y<0) head.y=this.gridSize-1;
    if(head.y>=this.gridSize) head.y=0;
    const ate = (head.x===food.x && head.y===food.y);
    if(!ate) this.body.pop();
    this.body.unshift(head);
    return ate;
  }
  checkCollision(){
    const [head,...rest]=this.body;
    return rest.some(s => s.x===head.x && s.y===head.y);
  }
}
</script>
</body>
</html>
