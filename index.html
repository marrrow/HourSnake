<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Make it responsive on mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HourSnake - Swipe + Arrow Keys</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #1a1a1a;
      color: #fff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }

    h1 {
      margin: 10px 0;
      text-align: center;
    }

    #credits, #leaderboard, #countdown {
      margin: 10px 0;
      text-align: center;
    }

    button {
      background: #4CAF50;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #45a049;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }

    /* Responsive container for the canvas */
    #game-container {
      position: relative;
      width: 90vw; /* 90% of screen width on mobile */
      max-width: 500px; /* limit on desktop */
      height: 90vw;
      max-height: 500px;
      margin: 20px auto;
      border: 2px solid #4CAF50;
      background: #000;
    }
    /* The canvas inside it is normal 400x400, but scaled by CSS to fill parent */
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #game-over {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      width: 80%;
    }
  </style>
</head>
<body>
  <h1>Snake Game (Swipe + Arrows)</h1>

  <!-- Show user's current credits -->
  <div id="credits">Credits: Loading...</div>

  <!-- Button to pay 1 star per attempt -->
  <button id="pay-button" onclick="payAndStartGame()">Pay 1 Credit to Play</button>

  <!-- Leaderboard button: fetch from the server anytime -->
  <button id="leaderboard-button" onclick="fetchCurrentLeaderboard()">View Leaderboard</button>

  <!-- Quick top-up instructions -->
  <button id="topup-button" onclick="topUpInfo()">Top Up Credits</button>

  <!-- Countdown to next hour (if you do hourly rewards) -->
  <div id="countdown">Next rewards in: Loading...</div>

  <!-- Current hourâ€™s top 10 scoreboard -->
  <div id="leaderboard">Leaderboard: Loading...</div>

  <!-- Snake Game Container -->
  <div id="game-container">
    <canvas id="game-canvas" width="400" height="400"></canvas>

    <div id="game-over">
      <h2>Game Over!</h2>
      <p>Your score: <span id="final-score">0</span></p>
      <p>Press "Pay 1 Credit to Play" for a new run.</p>
    </div>
  </div>

  <script>
    const backendUrl = "https://hoursnake.onrender.com"; 
    let telegramUserId;

    // We store game variables outside
    let canvas, ctx, gameInterval;
    let snake, food, dx, dy, score;

    // For swipe detection
    let touchStartX = null, touchStartY = null;
    const SWIPE_THRESHOLD = 30; // minimum pixels to count as a swipe

    window.onload = function() {
      // Attempt Telegram initialization
      try {
        const tg = Telegram.WebApp;
        tg.requestFullscreen();
        telegramUserId = tg.initDataUnsafe?.user?.id;
        if (!telegramUserId) {
          alert("No Telegram user ID. Are you inside Telegram WebApp?");
        }
      } catch (err) {
        console.error("Error initializing Telegram:", err);
      }

      // Periodic updates
      setInterval(updateCountdown, 1000);
      setInterval(fetchCurrentLeaderboard, 15000); // update leaderboard every 15s

      fetchCredits();
      fetchCurrentLeaderboard();
    };

    /* ============ 1) GET CURRENT CREDITS ============ */
    async function fetchCredits() {
      if (!telegramUserId) return;
      try {
        const resp = await fetch(`${backendUrl}/game/get-credits`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ telegram_id: telegramUserId })
        });
        const data = await resp.json();
        if (data.success) {
          document.getElementById("credits").innerText = `Credits: ${data.credits}`;
        } else {
          document.getElementById("credits").innerText = "Credits: Error";
        }
      } catch (err) {
        console.error("Error fetching credits:", err);
        document.getElementById("credits").innerText = "Credits: Error";
      }
    }

    /* ============ 2) PAY 1 STAR, THEN START GAME ============ */
    async function payAndStartGame() {
      if (!telegramUserId) {
        alert("No Telegram user ID. Are we inside Telegram?");
        return;
      }
      try {
        const resp = await fetch(`${backendUrl}/game/deduct-credit`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ telegram_id: telegramUserId })
        });
        const data = await resp.json();
        if (data.success) {
          alert("1 credit deducted. Starting snake...");
          document.getElementById("pay-button").disabled = true;
          fetchCredits();
          startGame();
        } else {
          alert(data.message || "Not enough credits. Please top up first.");
        }
      } catch (error) {
        console.error("Error deducting credit:", error);
        alert("Could not deduct credit. Check console logs.");
      }
    }

    function topUpInfo() {
      alert("To top up credits, contact admin or a website.\n" +
            "Then admin calls /admin/manual-topup with your ID.\n" +
            "Refresh credits here after!");
    }

    /* ============ 3) LEADERBOARD ============ */
    async function fetchCurrentLeaderboard() {
      try {
        const resp = await fetch(`${backendUrl}/current-leaderboard`);
        const data = await resp.json();
        if (!data.success) {
          document.getElementById("leaderboard").innerText = "Error loading leaderboard.";
          return;
        }
        let html = "<h3>Current Hour Leaderboard</h3>";
        if (data.leaderboard.length === 0) {
          html += "<p>No scores yet this hour.</p>";
        } else {
          data.leaderboard.forEach((entry, idx) => {
            html += `<p>${idx+1}. ${entry.username || "Anonymous"} - ${entry.score}</p>`;
          });
        }
        document.getElementById("leaderboard").innerHTML = html;
      } catch (err) {
        console.error("Error fetching leaderboard:", err);
        document.getElementById("leaderboard").innerText = "Leaderboard: Error";
      }
    }

    /* ============ 4) COUNTDOWN ============ */
    function updateCountdown() {
      const now = Date.now();
      const nextHour = now - (now % 3600000) + 3600000;
      const diff = nextHour - now;
      const m = Math.floor(diff / 60000);
      const s = Math.floor((diff % 60000) / 1000);
      document.getElementById("countdown").innerText =
        `Next rewards in: ${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    /* ============ 5) SNAKE GAME LOGIC ============ */
    function startGame() {
      // Hide game-over overlay if visible
      document.getElementById("game-over").style.display = "none";

      // Initialize snake data
      snake = [{ x: 10, y: 10 }];
      food = { x: 15, y: 15 };
      dx = 1; dy = 0;
      score = 0;

      canvas = document.getElementById("game-canvas");
      ctx = canvas.getContext("2d");

      // Keydown for arrow keys
      document.addEventListener("keydown", handleKeyDown);
      // Touch events for swipes
      canvas.addEventListener("touchstart", handleTouchStart, false);
      canvas.addEventListener("touchend", handleTouchEnd, false);

      // Game loop
      gameInterval = setInterval(() => {
        update();
        draw();
      }, 200);
    }

    function draw() {
      // Clear
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw snake
      snake.forEach(segment => {
        ctx.fillStyle = "lime";
        ctx.fillRect(segment.x * 20, segment.y * 20, 20, 20);
      });

      // Draw food
      ctx.fillStyle = "red";
      ctx.fillRect(food.x * 20, food.y * 20, 20, 20);
    }

    function update() {
      // Next head
      const head = { x: snake[0].x + dx, y: snake[0].y + dy };
      // Check eat
      if (head.x === food.x && head.y === food.y) {
        score++;
        food = {
          x: Math.floor(Math.random() * 20),
          y: Math.floor(Math.random() * 20)
        };
      } else {
        snake.pop(); // remove tail
      }
      // Add new head
      snake.unshift(head);

      // Check collision (walls or self)
      if (
        head.x < 0 || head.y < 0 ||
        head.x >= 20 || head.y >= 20 ||
        snake.slice(1).some(s => s.x === head.x && s.y === head.y)
      ) {
        endGame(score);
      }
    }

    function endGame(finalScore) {
      clearInterval(gameInterval);

      // Remove event listeners so we don't double up
      document.removeEventListener("keydown", handleKeyDown);
      canvas.removeEventListener("touchstart", handleTouchStart);
      canvas.removeEventListener("touchend", handleTouchEnd);

      // Show overlay
      document.getElementById("final-score").innerText = finalScore;
      document.getElementById("game-over").style.display = "block";

      // Re-enable pay button
      document.getElementById("pay-button").disabled = false;

      // Submit final score
      if (telegramUserId && typeof finalScore === "number") {
        fetch(`${backendUrl}/game/submit-score`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ telegram_id: telegramUserId, score: finalScore })
        })
        .then(r => r.json())
        .then(resp => {
          console.log("Score submission response:", resp);
          // Refresh leaderboard
          fetchCurrentLeaderboard();
        })
        .catch(err => console.error("Error submitting score:", err));
      }
    }

    // 6) ARROW KEY CONTROLS (no click needed)
    function handleKeyDown(e) {
      e.preventDefault(); // so arrow keys won't scroll on mobile
      switch(e.key) {
        case "ArrowUp":
          if (dy === 0) { dx = 0; dy = -1; }
          break;
        case "ArrowDown":
          if (dy === 0) { dx = 0; dy = 1; }
          break;
        case "ArrowLeft":
          if (dx === 0) { dx = -1; dy = 0; }
          break;
        case "ArrowRight":
          if (dx === 0) { dx = 1; dy = 0; }
          break;
        default:
          break;
      }
    }

    // 7) SWIPE CONTROLS (mobile)
    function handleTouchStart(e) {
      if (e.touches.length === 1) {
        // single touch
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    }

    function handleTouchEnd(e) {
      if (!touchStartX || !touchStartY) return;
      const xUp = e.changedTouches[0].clientX;
      const yUp = e.changedTouches[0].clientY;

      const dxSwipe = xUp - touchStartX;
      const dySwipe = yUp - touchStartY;

      // reset
      touchStartX = null;
      touchStartY = null;

      if (Math.abs(dxSwipe) < SWIPE_THRESHOLD && Math.abs(dySwipe) < SWIPE_THRESHOLD) {
        // swipe not big enough
        return;
      }

      // horizontal vs vertical
      if (Math.abs(dxSwipe) > Math.abs(dySwipe)) {
        // horizontal
        if (dxSwipe > 0) {
          // right
          if (dx === 0) { dx = 1; dy = 0; }
        } else {
          // left
          if (dx === 0) { dx = -1; dy = 0; }
        }
      } else {
        // vertical
        if (dySwipe > 0) {
          // down
          if (dy === 0) { dx = 0; dy = 1; }
        } else {
          // up
          if (dy === 0) { dx = 0; dy = -1; }
        }
      }
    }
  </script>
</body>
</html>
